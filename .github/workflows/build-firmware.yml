name: Build ESP32 Web Installer Firmware

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        variant:
          - { name: "24_ILI9341", flag: "24_ILI9341", output: "24-ili9341" }
          - { name: "24_ST7789", flag: "24_ST7789", output: "24-st7789" }
          - { name: "28_ILI9341", flag: "28_ILI9341", output: "28-ili9341" }

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Cache Arduino CLI
      uses: actions/cache@v4
      with:
        path: |
          ~/.arduino15
          ~/Arduino/libraries
        key: ${{ runner.os }}-arduino-esp32-3.0.4-${{ hashFiles('**/*.ino') }}
        restore-keys: |
          ${{ runner.os }}-arduino-esp32-3.0.4-

    - name: Setup Arduino CLI
      uses: arduino/setup-arduino-cli@v1

    - name: Install ESP32 platform
      run: |
        arduino-cli config init --overwrite
        arduino-cli core update-index
        arduino-cli core install esp32:esp32@3.0.4

    - name: Install required libraries
      run: |
        arduino-cli lib install "ArduinoJson@7.0.4"
        arduino-cli lib install "TFT_eSPI@2.5.43"
        arduino-cli lib install "WiFiManager@2.0.17"
        arduino-cli lib install "XPT2046_Touchscreen@1.4"
        arduino-cli lib install "lvgl@9.2.0"

    - name: Setup LVGL configuration
      run: |
        # Find LVGL library path and copy configuration
        LVGL_LIB_PATH=$(find /home/runner/Arduino/libraries -name "lvgl" -type d | head -1)
        echo "LVGL library path: $LVGL_LIB_PATH"
        if [ -n "$LVGL_LIB_PATH" ]; then
          cp lvgl/src/lv_conf.h "$LVGL_LIB_PATH/lv_conf.h"
          cp lvgl/src/lv_conf.h "$(dirname "$LVGL_LIB_PATH")/lv_conf.h"
          echo "Copied lv_conf.h to LVGL library and parent directory"
        else
          echo "ERROR: LVGL library not found"
          exit 1
        fi

    - name: Setup TFT_eSPI configuration
      run: |
        TFT_LIB_PATH=$(find /home/runner/Arduino/libraries -name "TFT_eSPI" -type d | head -1)
        echo "TFT_eSPI library path: $TFT_LIB_PATH"
        if [ -n "$TFT_LIB_PATH" ]; then
          cp TFT_eSPI/User_Setup.h "$TFT_LIB_PATH/User_Setup.h"
        else
          echo "ERROR: TFT_eSPI library not found"
          exit 1
        fi

    - name: Build firmware for ${{ matrix.variant.name }}
      run: |
        echo "Building ${{ matrix.variant.name }}"
        
        # Try multiple board configurations to find one that works
        BOARD_CONFIGS=(
          "esp32:esp32:esp32wroom32"
          "esp32:esp32:esp32"
          "esp32:esp32:esp32wrover"
        )
        
        BUILD_SUCCESS=false
        for BOARD_FQBN in "${BOARD_CONFIGS[@]}"; do
          echo "Trying board configuration: $BOARD_FQBN"
          
          # Build firmware with current board configuration
          if arduino-cli compile \
            --fqbn "${BOARD_FQBN}:PSRAM=disabled,PartitionScheme=huge_app,CPUFreq=240,FlashMode=dio,FlashFreq=40,FlashSize=4M,UploadSpeed=921600,DebugLevel=none" \
            --build-property "build.extra_flags=-DAURA_SCREEN=${{ matrix.variant.flag }} -DCORE_DEBUG_LEVEL=0 -DBOARD_HAS_PSRAM=0" \
            --output-dir build/${{ matrix.variant.name }} \
            aura; then
            
            echo "SUCCESS: Build completed for ${{ matrix.variant.name }} with $BOARD_FQBN"
            BUILD_SUCCESS=true
            break
          else
            echo "FAILED: Build failed for $BOARD_FQBN, trying next configuration..."
          fi
        done
        
        if [ "$BUILD_SUCCESS" = false ]; then
          echo "ERROR: All board configurations failed"
          exit 1
        fi
        
        # Verify the build completed successfully
        ls -la build/${{ matrix.variant.name }}/*.bin || echo "No .bin files found"

    - name: Install esptool for binary merging
      run: |
        pip install esptool

    - name: Create merged firmware binary
      run: |
        # Find the ESP32 core path for system binaries
        ESP32_PATH=$(find ~/.arduino15/packages/esp32/hardware/esp32 -name "3.0.4" -type d | head -1)
        echo "ESP32 path: $ESP32_PATH"
        
        if [ -z "$ESP32_PATH" ]; then
          echo "ERROR: ESP32 core 3.0.4 not found"
          exit 1
        fi
        
        # Try different paths for bootloader and boot_app0 binaries
        BOOTLOADER_PATH=""
        BOOT_APP0_PATH=""
        
        # Check common locations for bootloader
        for path in "$ESP32_PATH/tools/sdk/esp32/bin" "$ESP32_PATH/tools/sdk/bin" "$ESP32_PATH/tools/partitions"; do
          if [ -f "$path/bootloader_dio_40m.bin" ]; then
            BOOTLOADER_PATH="$path/bootloader_dio_40m.bin"
            break
          fi
        done
        
        # Check common locations for boot_app0
        for path in "$ESP32_PATH/tools/partitions" "$ESP32_PATH/tools/sdk/esp32/bin" "$ESP32_PATH/tools/sdk/bin"; do
          if [ -f "$path/boot_app0.bin" ]; then
            BOOT_APP0_PATH="$path/boot_app0.bin"
            break
          fi
        done
        
        # If not found, search recursively
        if [ -z "$BOOTLOADER_PATH" ]; then
          BOOTLOADER_PATH=$(find "$ESP32_PATH" -name "bootloader_dio_40m.bin" -type f | head -1)
        fi
        if [ -z "$BOOTLOADER_PATH" ]; then
          BOOTLOADER_PATH=$(find "$ESP32_PATH" -name "bootloader*.bin" -type f | head -1)
        fi
        if [ -z "$BOOT_APP0_PATH" ]; then
          BOOT_APP0_PATH=$(find "$ESP32_PATH" -name "boot_app0.bin" -type f | head -1)
        fi
        
        echo "Found bootloader: $BOOTLOADER_PATH"
        echo "Found boot_app0: $BOOT_APP0_PATH"
        
        # Validate required binaries exist
        if [ -z "$BOOTLOADER_PATH" ] || [ ! -f "$BOOTLOADER_PATH" ]; then
          echo "ERROR: Bootloader binary not found"
          exit 1
        fi
        if [ -z "$BOOT_APP0_PATH" ] || [ ! -f "$BOOT_APP0_PATH" ]; then
          echo "ERROR: boot_app0 binary not found"
          exit 1
        fi
        
        # Create output directory
        mkdir -p firmware
        
        # Extract partition table from build
        BUILD_DIR="build/${{ matrix.variant.name }}"
        SKETCH_NAME="aura.ino"
        
        # Find the generated files
        APP_BIN=$(find "$BUILD_DIR" -name "${SKETCH_NAME}.bin" -type f | head -1)
        BOOTLOADER_BIN=$(find "$BUILD_DIR" -name "${SKETCH_NAME}.bootloader.bin" -type f | head -1)
        PARTITIONS_BIN=$(find "$BUILD_DIR" -name "${SKETCH_NAME}.partitions.bin" -type f | head -1)
        
        echo "App binary: $APP_BIN"
        echo "Bootloader binary: $BOOTLOADER_BIN"
        echo "Partitions binary: $PARTITIONS_BIN"
        
        # Verify binary files exist and show their info
        if [ -f "$APP_BIN" ]; then
          echo "App binary size: $(du -h "$APP_BIN" | cut -f1)"
          # Check for ESP32 magic bytes and chip target
          echo "App binary header (chip target check):"
          xxd -l 32 "$APP_BIN" | head -2
        fi
        
        # Use the built-in generated binaries if available, otherwise use system defaults
        if [ -f "$BOOTLOADER_BIN" ]; then
          FINAL_BOOTLOADER="$BOOTLOADER_BIN"
          echo "Using sketch-generated bootloader: $BOOTLOADER_BIN"
        else
          FINAL_BOOTLOADER="$BOOTLOADER_PATH"
          echo "Using system bootloader: $BOOTLOADER_PATH"
        fi
        
        if [ -f "$PARTITIONS_BIN" ]; then
          FINAL_PARTITIONS="$PARTITIONS_BIN"
          echo "Using sketch-generated partitions: $PARTITIONS_BIN"
        else
          echo "ERROR: Partitions binary not found"
          exit 1
        fi
        
        # Verify bootloader has correct chip ID (should start with 0xE9 for ESP32)
        if [ -f "$FINAL_BOOTLOADER" ]; then
          echo "Bootloader header (chip ID check):"
          xxd -l 16 "$FINAL_BOOTLOADER" | head -1
          echo "Checking bootloader chip target..."
          CHIP_ID=$(xxd -l 1 -p "$FINAL_BOOTLOADER" | head -c 2)
          echo "Bootloader chip ID: 0x$CHIP_ID"
        fi
        
        # Merge all binaries into single firmware file with correct chip specification
        OUTPUT_NAME="aura-firmware-${{ matrix.variant.output }}"
        esptool.py --chip esp32 merge_bin \
          -o firmware/${OUTPUT_NAME}.bin \
          --flash_mode dio \
          --flash_freq 40m \
          --flash_size 4MB \
          0x1000 "$FINAL_BOOTLOADER" \
          0x8000 "$FINAL_PARTITIONS" \
          0xe000 "$BOOT_APP0_PATH" \
          0x10000 "$APP_BIN"
        
        echo "Created merged firmware: firmware/${OUTPUT_NAME}.bin"
        ls -la firmware/

    - name: Create manifest file
      run: |
        # Get version from git ref or use 'development'
        if [[ "${{ github.ref }}" == refs/tags/* ]]; then
          VERSION="${{ github.ref_name }}"
        else
          VERSION="development"
        fi
        
        OUTPUT_NAME="aura-firmware-${{ matrix.variant.output }}"
        # Create manifest JSON for web installer
        cat > firmware/manifest-${{ matrix.variant.output }}.json << EOF
        {
          "name": "Aura ${{ matrix.variant.name }}",
          "version": "$VERSION",
          "home_assistant_domain": "esphome",
          "new_install_prompt_erase": true,
          "builds": [
            {
              "chipFamily": "ESP32",
              "parts": [
                {
                  "path": "${OUTPUT_NAME}.bin",
                  "offset": 0
                }
              ]
            }
          ]
        }
        EOF
        
        echo "Created manifest: firmware/manifest-${{ matrix.variant.output }}.json"
        cat firmware/manifest-${{ matrix.variant.output }}.json

    - name: Upload firmware artifacts
      uses: actions/upload-artifact@v4
      with:
        name: firmware-${{ matrix.variant.output }}
        path: firmware/
        retention-days: 30

  release:
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/')
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts/

    - name: Prepare release assets
      run: |
        mkdir -p release-assets
        
        # Collect all firmware and manifest files
        find artifacts/ -name "*.bin" -exec cp {} release-assets/ \;
        find artifacts/ -name "*.json" -exec cp {} release-assets/ \;
        
        echo "Release assets prepared:"
        ls -la release-assets/
        
        # Verify we have all expected files
        EXPECTED_FILES=(
          "aura-firmware-24-ili9341.bin"
          "aura-firmware-24-st7789.bin" 
          "aura-firmware-28-ili9341.bin"
          "manifest-24-ili9341.json"
          "manifest-24-st7789.json"
          "manifest-28-ili9341.json"
        )
        
        for file in "${EXPECTED_FILES[@]}"; do
          if [ ! -f "release-assets/$file" ]; then
            echo "ERROR: Missing expected file: $file"
            exit 1
          else
            echo "✓ Found: $file ($(du -h "release-assets/$file" | cut -f1))"
          fi
        done

    - name: Create Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ github.ref_name }}
        name: Aura Weather Display ${{ github.ref_name }}
        body: |
          ## Aura Weather Display Firmware Release ${{ github.ref_name }}
          
          ### Web Installer Compatible Firmware
          
          Use the [Aura Web Installer](https://oakesekao.github.io/aura-installer/) for easy one-click firmware installation.
          
          ### Supported Variants
          - **24-ili9341** - 2.4 inch displays with ILI9341 driver
          - **24-st7789** - 2.4 inch displays with ST7789 driver  
          - **28-ili9341** - 2.8 inch displays with ILI9341 driver (most common)
          
          ### Files Included
          
          **Firmware Files (for web installer):**
          - `aura-firmware-24-ili9341.bin` - Merged firmware for 2.4" ILI9341
          - `aura-firmware-24-st7789.bin` - Merged firmware for 2.4" ST7789
          - `aura-firmware-28-ili9341.bin` - Merged firmware for 2.8" ILI9341
          
          **Manifest Files (for web installer):**
          - `manifest-24-ili9341.json` - Web installer configuration for 2.4" ILI9341
          - `manifest-24-st7789.json` - Web installer configuration for 2.4" ST7789
          - `manifest-28-ili9341.json` - Web installer configuration for 2.8" ILI9341
          
          ### Manual Installation
          
          If you prefer manual flashing with esptool:
          
          ```bash
          esptool.py --chip esp32 --port /dev/ttyUSB0 write_flash 0x0 aura-firmware-{variant}.bin
          ```
          
          ### Technical Details
          
          - ESP32 Core: 3.0.4 (web installer compatible)
          - Partition Scheme: huge_app (4MB)
          - Flash Mode: DIO, 40MHz
          - All binaries merged for single-file flashing at offset 0x0
          
          ### Changes in this Release
          - Web installer compatible merged firmware binaries
          - Proper ESP32 core version for chip ID compatibility  
          - Optimized memory usage and performance
          - Support for multiple display variants
        files: release-assets/*
        draft: false
        prerelease: false
        fail_on_unmatched_files: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
